1. java中的对象序列化和反序列化是java对象和字节序列相互转换的过程。反序列化还原对象的过程是不需要走构造方法的。
2. 当一个对象的实例变量引用其他对象，序列化该对象时也要把引用对象进行序列化。
3. 同一个对象序列化多次，并不会将这个对象序列化多次。同理，将一个对象反序列化回来时，比对两个对象的`==`返回的是true。
原因是java所有保持到磁盘上的对象都有一个序列化编号，当程序在执行序列化或者反序列化时会检查对象编号是否已经序列化过了，没有执行过才会执行序列化，执行过后会执行输出编号。
同理，在对象序列化后修改部分属性字段，再次执行序列化操作，虽然能执行成功，但是磁盘上保存的依然是旧的属性值。因为后面的序列化操作输出的都是序列号。
4. 对于不需要序列化的属性，可以使用transient关键字修饰。忽略序列化字段并不是忽略整个属性，反序列化时属性依然存在，但是值为默认值。应用类型为null，基本类型为0，boolean是false。
5. 静态变量也不会被序列化。
6. 对象的序列化除了serializable接口，还存在一个Externalizable接口。实现Externalizable接口强制要求程序员实现writeExternal()和readExternal()。这种自定义序列化方式性能好，但是比较麻烦，很少被用到。
7. serialVersionUID并不是必须的，但是建议指定。在未指定的情况下，jvm会根据类信息自己计算一个版本号。但是不同的jvm计算规则可能不同。
反序列化必须拥有class文件，当class文件升级(增删属性时)，只要serialVersionUID一致，对象就能还原回来(增删的属性会设置默认值)。
