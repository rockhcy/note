###### 2020-10-28 今天开始学习C++，目标一个月后能开始写IDP的客户端
##### day01 基础api部分
1. C++的整形类型和java不同，其中long很特别，在windows下为4字节，32位的linux下为4字节，64位的linux下为8字节
2. 关于浮点型，C++也有float和double两种。但是小数默认为double，就算声明是float，小数位后面还是需要添加一个f,否则依然会被认为是double。（PS：java也是这么处理的，区别是编译器会报错，强制要求你添加f）
3. 一个char的长度是256，范围为-128~127.0占用了一个位置，所以正数部分只有127.Ascll 就是取用了char正数部分，一共127各编码。0~31属于非打印控制字符，用于控制打印机等外围设备；32~126分配给了键盘上能找到的字符，包括数字、字母、符号和部分功能键(space、del等)，其中字母的大小写会分别对应不同的Ascll码。
非打印字符：指在计算机中有一些字符是确确实实存在,但是它们不能够显示或者打印出来符号，比如回车、换行等，不能打印，但是是确实存在的。
4. C中的字符串声明为`char str[] = "helloworld"`,C++ 中的声明为`string str = "hello world"`.
(hcyps：疑问？讲义中说C++使用字符串需引入#include<string>,我测试的时候没有引入也能输出，且没报错，为什么？ 答)
5. C++ 中的布尔类型声明时可以赋值true或者false，输出打印时显示为1和0，而java打印时默认为true和false的字符串。
6. C++中的变量不允许不复制就直接使用，否则程序闪退。也不能重复定义同名变量，定义后编译器不报错，但是不能编译。
7. C++ 中的浮点数是不能进行取模运算的，编译器直接提示语法错误。java中的浮点数是可以取模的，但是取模结果很诡异，感觉没有意义，因为无法一眼看出计算公式。
8. C++中的switch 只能接收整型和char，不能接收string，java中的可以为string
9. C++虽然有goto 关键字，但是编码时不建议使用。不是goto有缺陷，而是人的习惯问题。
10. C++ 中的数组在申明后如果没有全部填充值，系统会给默认值，string 和char数组的默认填充空字符串，整型和浮点型都是填充0
11. C++中的函数声明，自定义函数必须放在头文件后，main方法前。 
  (cyps：疑问？奇怪的是，我将自定义函数放在main后面也能执行，但是执行顺序会变得很奇怪)
12. C++中的函数分文件编写感觉好奇怪，过程如下
a.先创建一个.h的头文件，在其中写入函数的申明。感觉优点向java中的接口，只是标记会有那些方法，但是没有做具体实现。
(hcyps:疑问？如果是接口，为什么需要include<iostream> 和using namespace std;他们是做什么用的，namespace起到什么作用？)
b.创建一个.cpp的源文件，在源文件的开始位置引入头文件，然后就可以开始写函数的实现了。
c.在需要调用的地方直接进入头文件就能调用里面的方法了。C++不是纯面向对象的语言，因为不会强制要求所有方法和属性都必须"对象."才能获取到，需要习惯这种方式。
13. 关于指针，java和C++最大的区别之一。
a.java是存面向对象的语言，没有指针的概念。C++有指针，定义时需要指定指针类型。Go也有指针类型，但是Go的变量声明类似js，会做类型推导，自动判定指针类型。
b.通过`&变量`的方式可以将变量地址赋给指针，通过`*指针变量`可以获取到对应内存地址的值，这个写法叫'解引用'
c.const 关键字修饰指针时表示指针的值不能在被修改，但是指针还是可以修改指向其他的内存地址
d.c++和java一样，方法都是值传递。但是c++有指针，如果方法中传入的参数为指针类型，是可以通过指针直接修改对应内存区域的值的，也被称为引用传递。
e. 指针类型指向变量时需要“&变量名”，指向数组时直接写数组名称就可以了，此时的指针会指向数组的第一个元素位置，通过解引用可以取到元素值，++指针变量可以移动指针
14. 关于struct结构体：C++的结构体和go一样，通过关键字struct声明，允许嵌套。传递时可以传递值、地址、和指针。传递地址和指针是一回事。

##### day02 
1. 关于C++的内存模型，待补充
2. 关于函数
a.java中的重载是通过函数名，参数和返回值确认唯一性，c++只看函数名和参数列表，返回值不能作为重载条件。因为没有类的概念，C++的函数重载需要函数在一个作用域中。
3. 关于C++中的面向对象：C++通过class关键字来创建对象，然后在其内部定义方法和属性，通过public和private来确定访问权限。这点和java的类还是有点相似的，golang中的面向对象更加简洁，通过大小写来确认访问权限，感觉玩法都差不多。
注意：C++中的struct和class都能构建结构体，但是struct的默认权限是公共的，class默认是私有的，除非在public域下定义方法和属性，go中没有class，只有struct。
4. 关于构造函数，java只有有参构造和无参构造的区别，编译器默认提供无参构造，如果用户提供了有参构造，则不会在提供无参构造。这个特点C++也有，但是c++在此基础上添加了拷贝构造函数的概念，编译器默认会提供拷贝构造函数，且默认是浅拷贝，要修改只能通过用户自定义来顶替掉它。当class属性有在堆区开辟的情况时(比如属性为一个指针时),一定要自己提供拷贝函数，防止析构函数重复释放同一片区域的问题。
讲义原话是"如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题"
5. c++中被const修饰的对象叫做“常对象”，常对象的属性可以访问，但是不能修改(被mutable修饰的属性除外)。同时，常对象只能调用常函数。
常函数：被const修饰的函数，常函数不能修改成员属性值，被mutable修饰的属性除外。
6. 友元:java中的私有属性可以通过反射来调用，而C++的解决方式是提供一个friend关键字，让一个函数或者类访问另外一个类中的私有成员。感觉有点花哨，用到时在细究。
7. 运算符重载，一种分为5种，
a加号运算符重载，类似于java中的compater接口的作用。在方法名后面添加`+`来实现。本来只有int，long、double等基本类型才能做+运算。使用加号重载符后可以将自定义类型也做加法运算，加法逻辑由重载方法决定。
b左位移运算符，通过在函数`operator<<`来实现。可以输出自定义数据类型，实现链式调用。java中要实现这个效果需要让多个方法都返回同一个类对象，语法比较繁琐，c++左位移运算符原则上和它差不多，只是语法更加简洁。
c递增运算符重载，通过函数`operator++` 和friend 友元 来实现，用于属性递增。作用也是简化语法。
d赋值运算符重载，通过函数`operator=`来实现，用于解决深浅拷贝问题。c++编译器自少会给类添加4个函数，分别是：无参构造函数，无参析构函数，拷贝构造函数和赋值运算函数。前面3个的函数明就是类名，只有这个赋值运算函数是`operator=`名称。它的作用也是简化语句，这样就能直接用赋值操作完成深拷贝。
e关系运算符重载，通过函数`operator==` 和`operator!=`来实现。java中比较两个对象一般使用equals，c++中的类通过着两个重载方法后，就能直接使用'=='比较两个对象了。
f函数调用运算符重载，也叫仿函数。通过函数`operator()`来实现，也是用于简化语句的。
java中的所有对象都集成自object，因此会有一些共通的方法可以使用。c++不是完全面向对象的，因此要实现面向对象就需要一些内置的东西来满足这些特性，于是就有了上面这些方法。正常情况下，方法名是不能包含符号的，但是上述方法可以。可以认为是编译器对这部分方法做了特殊的转义。他们的存在是为了简化语句，没有他们c++也能玩，就是会很麻烦，要多写很多代码。
8. 关于继承
C++的继承概念和java基本一致，都是抽取共性为基类，子类自己处理个性。区别是C++支持多继承，java不支持；调用方式上，C++使用`::`访问父类的方法和属性，java使用'super'关键字；对于静态变量和方法，c++可以使用对象访问，也能使用类访问，java中的static资源只支持类访问。
注意：c++中的static变量必须要赋值后才能访问，否则无法通过编译。而java中是可以打印的(为默认值或者null)。
9. 关于多态
c++中的多态和java中的多态概念是一样的，只是在实现方式上比较接近接口的处理方式。c++中没有interface，但是有一个virtual 关键字。virtual用来修饰函数，被其修饰的函数称为虚函数，如果整个类都是虚函数，这种类就被称为抽象类。抽象类不能实例化，且子类必须重写其中的纯虚函数，否则也是抽象类。
通过这种方式实现的多态方法通常传递的都是指针，这就很容易造成内存回收问题。因此c++又提供了析构语法`virtual ~类名(){}`和纯虚析构语法：`virtual ~类名() = 0;`来处理内存回收不干净的问题。
hcy疑问：
1.C++ 使用new关键字开辟空间，返回的是对应的指针类型。那么"int[] a ={10，20} ;"这种写法和直接new有什么区别吗？空间是都在堆中吗？
2.“2.4 引用做函数返回值” 这个章节没看太懂，要去刷下视频

##### day03 
1. 关于C++模板，和我预想的不太一样，在使用感觉上有点像java的object+反射+泛型。C++本身是一种强类型语言，而且不支持反射，这就意味着函数的复用性会很差。比如，需要将两个变量的值进行交换，但是变量的类型会有很多种，如果算上自定义的数据类型，那就没完没了了。为了解决这个问题C++提供了模板语法来解决这个问题。模板语法分为函数模板和类模板：
函数模板：类似java的泛型，允许编写方法时不指定数据类型，在编译时指定或者自动推导类型。
类模板：类似java中的反射，区别是java的反射是运行时调用，而C++是发生在编译期。因为`T`可以是任何类型，但是它有不能直接调用到自定义类型种的各种属性或者函数(因为编译器无法确认是写的是否正确)。因此，可以在类中使用模板，这样`T`使用类中的成员时，编译器就知道怎么处理了。
---------------华丽的分割线---------
我的目标是使用c++写桌面程序。C++基础语法入门后就要准备开始学QT了。明天开始转战QT。
都说C++执行效率高，但是我还是认为后端使用java或者golang比较合适。
