##### 关于数组(array)和切片(slice)
无论是java还是go，数组作为基本的数据结构长度都是不能改变的。go中的切片类是java中的list。
在申明时有两种方式：
1.是通过 var slicename []type,这种方式和数组的申明方式是一样的，如果写明长度，它就是数组，没写他就是切片。
如果是数组，是不能直接使用append()改变大小的。如果是切片则可以随意添加元素
2.通过make,这种方式声明的一定是切片。slicename := make([]type,len),这种方式就算指定长度，也能再次扩容
go的基础库中貌似就打算使用slice作为java种的list使用。
##### 关于重载
go是不支持重载的，官方给出的理由是重载会让代码看起来很复杂，方法签名应该是唯一的。
这个观点我是支持的，比如rocketMQ中的sendMassage()，这玩意起码有上10个重载方法，看到那一排下拉框顿时心情就不好了。
那go是如何实现重载提供的便利性的呢？答案是动态参数...和interface类型。
... 在java中也有，两者区别不大。但是interface差别就很大了，详见下面一张。
##### 关于interface
go中的interface是一种数据类型，你可以在其中定义各种方法。当实例化接口类型对象时，需要你传入一个struct。而该struct必须实现了interface中的全部方法。在go中，这种处理方式更像是面向过程的。传入什么struct，就由什么struct执行接口对象调用的方法。
而java中的接口是用来约束子类的，他的本质是一个父类对象指向子类，因此它的落脚点还是子类。
java中的接口是通过关键字implements来形成关联关系，但是go中没有这种明显的关联关系，只要某个struct实现了interface中的方法，就算是关联上这个接口了。
不懂？？看下go的示例代码就好，这个地方初看会觉得很奇怪，琢磨下就好了。
##### 关于并发问题
java中的并发会存在3个知识点：线程、线程池、数据交换。将java和go对照比较，看看他们之间的差异。
先说线程和线程池：java中线程的创建和销毁是一个比较重的操作，因此Java提供了很多的线程池api方便管理。
线程池主要解决两个问题：一是线程复用，不免频繁的创建和回收；二是控制线程大小，避免线程数太多而拖垮系统。
而go中的线程属于协程(一种轻量级线程)。不考虑对线程数量管控的情况下，go中的线程已经具备了java中线程池的特点，由goroutine统一调度管理。
接下来我们说数据交换的问题，java是纯面向对象的语音，如果需要在线程间交换数据。可以通过callback或者future来获取线程中的返回值。然后再通过值传递进行数据交换。
go中的线程开启是通过go关键字来实现的，没有返回值这个说法。因此go提供了一个特殊的数据结构channel来解决这个问题。
通过channel传递的数据天然就是同步的，可以认为go中通过channel传递的数据天然加锁了互斥锁的。因此go中没有volatile关键字。
go关键字解决了开启线程的问题，channel解决了数据交换的问题。
##### 关于依赖
java中依赖管理使用maven，js使用的npm。go中的依赖拉取是基于GitHub的，但是这种方式不方便做版本控制。因为你无法保证再次拉取时远端的最后一个分支还是你原来的版本。因此go提供了mod功能。
从1.13开始就默认开启了。
要使用也很简单：go mod <项目名称>这种方式初始化的项目默认就开启了go mod。
##### 关于go在web后端方向上的框架选型
go基础库中提供了http的相关实现，两行代码就能实现一个简单的http服务，这或许就是go这种新语言的后发优势。
但是实际开发中，为了让项目方便管理，并且回避一些基础细节问题，框架还是有比较使用的。
go在web后端方向上的框架主要有三个：echo、gin、beego，我们分别对比下3个框架。
echo：它是3个框架中最轻量级的web框架，默认情况下它只完成了MVC中C的部分，也就是负责url路由和控制器部分，至于V视图层和M数据操作部分需要用户自己实现。前后端分离开发时用它开发后端服务完全是够用了的。
截止到2021-01-21，GitHub上是19K start。
Gin：比echo跟进一步，实现了V的部分。同样时间，在GitHub上是45k start，最高的一个。
Beego：相比Gin又进了一步，自己实现了ORM封装。也就是说MVC3层它全做了。相对的，做的越多，框架越重。同一时间，在GitHub上只有25.8k start.
我本来是想用echo的，越轻量的东西耦合性越小。但是考虑到GitHub上的排名，加上我刚转go。一个相对成熟的框架应该可以帮我规避掉一部分问题。
最终还是决定使用Gin。